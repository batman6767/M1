# app.py
"""
SPIDER — Single-page iOS-style Dark Streamlit app
- Yahoo Finance data
- Indicators: MA20, MA50, EMA, RSI, MACD, Bollinger Bands
- Forecasts: Prophet, ARIMA, Random Forest, LSTM
- All models run in one click
- Dark iOS-style UI, single centered page
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import timedelta

# --------------------------
# ML libraries
# --------------------------
HAS_PROPHET = False
HAS_ARIMA = False
HAS_SKLEARN = False
HAS_TF = False

try:
    from prophet import Prophet
    HAS_PROPHET = True
except:
    Prophet = None

try:
    from statsmodels.tsa.arima.model import ARIMA
    HAS_ARIMA = True
except:
    ARIMA = None

try:
    from sklearn.ensemble import RandomForestRegressor
    from sklearn.preprocessing import MinMaxScaler
    HAS_SKLEARN = True
except:
    RandomForestRegressor = None
    MinMaxScaler = None

try:
    import tensorflow as tf
    from tensorflow import keras
    from tensorflow.keras import layers
    HAS_TF = True
except:
    tf = None
    keras = None
    layers = None

# --------------------------
# Streamlit page config + CSS
# --------------------------
st.set_page_config(page_title="SPIDER", layout="wide")

st.markdown("""
<style>
body, .stApp {background-color: #000000; color: #E6E6E6; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', Roboto, sans-serif;}
.block-container {padding-top: 1.5rem; max-width: 1150px; margin-left:auto; margin-right:auto;}
.stButton>button {background-color: #1C1C1E; color: #E6E6E6; border-radius: 12px; border: 1px solid #2C2C2E; padding: 0.55em 1em;}
.stTextInput>div>div>input, .stSelectbox>div>div, .stSlider>div>div {background-color: #0F0F10; color: #E6E6E6; border-radius: 10px; border: 1px solid #222224;}
.stCheckbox>div, .stRadio>div {color: #E6E6E6;}
h1, h2, h3, h4 {color: #E6E6E6; text-align: center;}
.model-availability {background-color:#0B0B0C; padding:8px; border-radius:8px; border:1px solid #202022;}
</style>
""", unsafe_allow_html=True)

# --------------------------
# Disclaimer Gate
# --------------------------
st.markdown("## ⚠️ Disclaimer")
st.markdown("""
This application (“the App”) provides stock market data, analysis, and predictive tools for **educational and informational purposes only**.  

- The App does **not** provide financial, investment, trading, or legal advice.  
- All information, forecasts, and analytics generated by the App are **estimates only** and may be inaccurate, incomplete, or outdated.  
- Stock market investments are inherently **risky and volatile**. Past performance is not indicative of future results.  
- Users are solely responsible for any investment or trading decisions made based on the App’s content.  
- The developers, owners, affiliates, and contributors of the App shall **not be held liable** for any financial losses, damages, or consequences arising directly or indirectly from its use.  

By using the App, you acknowledge that you understand these risks and agree to use the App at your own discretion and responsibility.  
For personalized financial guidance, please consult a licensed financial advisor.
""")

accept = st.checkbox("✅ I have read and accept the disclaimer")

if not accept:
    st.warning("⚠️ Please accept the disclaimer to use the app.")
    st.stop()

# --------------------------
# Utilities
# --------------------------
@st.cache_data(ttl=300)
def fetch_yahoo_data(ticker: str, period="6mo", interval="1d") -> pd.DataFrame:
    try:
        t = yf.Ticker(ticker)
        df = t.history(period=period, interval=interval)
        if df is None or df.empty:
            return pd.DataFrame()
        df = df.reset_index()
        df['Date'] = pd.to_datetime(df['Date'])
        try:
            df['Date'] = df['Date'].dt.tz_localize(None)
        except Exception:
            df['Date'] = pd.to_datetime(df['Date']).dt.tz_localize(None)
        for col in ['Open','High','Low','Close','Volume']:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
        df = df.dropna(subset=['Date','Close']).reset_index(drop=True)
        return df
    except Exception:
        return pd.DataFrame()

def compute_indicators(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy().reset_index(drop=True)
    df['MA20'] = df['Close'].rolling(20).mean()
    df['MA50'] = df['Close'].rolling(50).mean()
    df['EMA12'] = df['Close'].ewm(span=12, adjust=False).mean()
    df['EMA26'] = df['Close'].ewm(span=26, adjust=False).mean()
    df['MACD'] = df['EMA12'] - df['EMA26']
    df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    df['BB_MID'] = df['Close'].rolling(20).mean()
    df['BB_STD'] = df['Close'].rolling(20).std(ddof=0).fillna(0)
    df['BB_UP'] = df['BB_MID'] + 2*df['BB_STD']
    df['BB_LOW'] = df['BB_MID'] - 2*df['BB_STD']
    delta = df['Close'].diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.rolling(14).mean()
    roll_down = down.rolling(14).mean()
    rs = roll_up / (roll_down + 1e-8)
    df['RSI'] = 100 - (100 / (1 + rs))
    df['RSI'] = df['RSI'].clip(0,100).fillna(50)
    return df

def plot_advanced(df: pd.DataFrame, title: str, show_indicators: bool = True):
    fig = make_subplots(rows=3, cols=1, shared_xaxes=True,
                        row_heights=[0.6,0.18,0.22],
                        vertical_spacing=0.03)
    fig.add_trace(go.Candlestick(x=df['Date'], open=df['Open'], high=df['High'],
                                 low=df['Low'], close=df['Close'], name='Price'), row=1, col=1)
    if show_indicators:
        fig.add_trace(go.Scatter(x=df['Date'], y=df['MA20'], name='MA20', line=dict(width=1.4)), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['MA50'], name='MA50', line=dict(width=1.4, dash='dash')), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['BB_UP'], name='BB_UP', line=dict(width=1, dash='dot')), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['BB_LOW'], name='BB_LOW', line=dict(width=1, dash='dot')), row=1, col=1)
    fig.add_trace(go.Bar(x=df['Date'], y=df['Volume'], name='Volume', marker_color='gray', opacity=0.3), row=2, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['RSI'], name='RSI', line=dict(width=1.2)), row=3, col=1)
    fig.add_hline(y=70, line_dash='dot', row=3, col=1)
    fig.add_hline(y=30, line_dash='dot', row=3, col=1)
    fig.update_layout(template='plotly_dark', title=title,
                      margin=dict(l=20,r=20,t=40,b=10),
                      paper_bgcolor='#000000', plot_bgcolor='#000000',
                      legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1))
    st.plotly_chart(fig, use_container_width=True, theme=None)

# --------------------------
# Forecasts (Prophet/ARIMA/RF/LSTM)
# --------------------------
def forecast_all(df: pd.DataFrame, periods: int = 30):
    forecasts = {}
    if HAS_PROPHET:
        try:
            prophet_df = df[['Date','Close']].rename(columns={'Date':'ds','Close':'y'}).copy()
            prophet_df['ds'] = pd.to_datetime(prophet_df['ds']).dt.tz_localize(None)
            m = Prophet(daily_seasonality=True, yearly_seasonality=True, weekly_seasonality=True)
            m.fit(prophet_df)
            future = m.make_future_dataframe(periods=periods, freq='D')
            future['ds'] = pd.to_datetime(future['ds']).dt.tz_localize(None)
            fc = m.predict(future)[['ds','yhat','yhat_lower','yhat_upper']].rename(columns={'ds':'Date'})
            forecasts['Prophet'] = fc
        except Exception as e:
            st.error(f"Prophet error: {e}")

    if HAS_ARIMA:
        try:
            series = df.set_index('Date')['Close'].sort_index()
            series.index = pd.to_datetime(series.index).tz_localize(None)
            daily_idx = pd.date_range(series.index.min(), series.index.max(), freq='D')
            series = series.reindex(daily_idx).ffill()
            model = ARIMA(series, order=(5,1,0)).fit()
            fc = model.forecast(steps=periods)
            dates = pd.date_range(start=series.index[-1]+timedelta(days=1), periods=periods)
            forecasts['ARIMA'] = pd.DataFrame({'Date': dates, 'yhat': fc.values})
        except Exception as e:
            st.error(f"ARIMA error: {e}")

    if HAS_SKLEARN:
        try:
            data = df[['Close']].copy()
            n_lags = 5
            for lag in range(1,n_lags+1):
                data[f'lag_{lag}'] = data['Close'].shift(lag)
            data = data.dropna()
            X = data[[f'lag_{i}' for i in range(1,n_lags+1)]].values
            y = data['Close'].values
            model = RandomForestRegressor(n_estimators=200, random_state=42)
            model.fit(X, y)
            last_window = X[-1].tolist()
            preds = []
            for _ in range(periods):
                p = float(model.predict([last_window]))
                preds.append(p)
                last_window = [p]+last_window[:-1]
            dates = pd.date_range(start=df['Date'].iloc[-1]+timedelta(days=1), periods=periods)
            forecasts['RandomForest'] = pd.DataFrame({'Date': dates, 'yhat': preds})
        except Exception as e:
            st.error(f"RandomForest error: {e}")

    if HAS_TF and HAS_SKLEARN:
        try:
            values = df['Close'].values.astype('float32')
            n_lags = 20
            scaler = MinMaxScaler()
            scaled = scaler.fit_transform(values.reshape(-1,1)).flatten()
            X, y = [], []
            for i in range(n_lags, len(scaled)):
                X.append(scaled[i-n_lags:i])
                y.append(scaled[i])
            X = np.array(X).reshape(-1, n_lags, 1)
            y = np.array(y)
            tf.keras.backend.clear_session()
            model = keras.Sequential([
                layers.Input(shape=(n_lags,1)),
                layers.LSTM(64, return_sequences=False),
                layers.Dense(32, activation='relu'),
                layers.Dense(1)
            ])
            model.compile(optimizer='adam', loss='mse')
            model.fit(X, y, epochs=10, batch_size=16, verbose=0)
            last_window = list(scaled[-n_lags:])
            preds_scaled = []
            for _ in range(periods):
                x = np.array(last_window).reshape(1, n_lags, 1)
                p = float(model.predict(x, verbose=0)[0,0])
                preds_scaled.append(p)
                last_window = last_window[1:]+[p]
            preds = scaler.inverse_transform(np.array(preds_scaled).reshape(-1,1)).flatten().tolist()
            dates = pd.date_range(start=df['Date'].iloc[-1]+timedelta(days=1), periods=periods)
            forecasts['LSTM'] = pd.DataFrame({'Date': dates, 'yhat': preds})
        except Exception as e:
            st.error(f"LSTM error: {e}")

    return forecasts

# --------------------------
# Main UI
# --------------------------
st.title("M1")

tickers_list = [
    "AAPL","MSFT","GOOG","AMZN","TSLA","META","NVDA","JPM","V","JNJ","WMT",
    "RELIANCE.NS","TCS.NS","INFY.NS","HDFCBANK.NS","ICICIBANK.NS","SBIN.NS",
    "BTC-USD","ETH-USD"
]

controls = st.columns([2,2,2,2,1])
with controls[0]:
    ticker = st.selectbox("Ticker", tickers_list, index=0)
with controls[1]:
    period = st.selectbox("History period", ["1mo","3mo","6mo","1y","2y","5y","10y","max"], index=2)
with controls[2]:
    interval = st.selectbox("Interval", ["1d","1wk","1mo"], index=0)
with controls[3]:
    show_indicators = st.checkbox("Show Indicators", value=True)
with controls[4]:
    run = st.button("Run All")

st.markdown("---")

if run:
    df = fetch_yahoo_data(ticker, period, interval)
    if df.empty:
        st.error("No data retrieved. Check ticker or network.")
        st.stop()
    df = compute_indicators(df)

    last = df.iloc[-1]
    cols = st.columns([1,1,1,1,1])
    with cols[0]: st.metric("Date", str(pd.to_datetime(last['Date']).date()))
    with cols[1]: st.metric("Open", f"{last['Open']:.2f}")
    with cols[2]: st.metric("High", f"{last['High']:.2f}")
    with cols[3]: st.metric("Low", f"{last['Low']:.2f}")
    with cols[4]: st.metric("Close", f"{last['Close']:.2f}")

    plot_advanced(df, f"{ticker} — Price & Indicators", show_indicators)

    st.download_button("Download raw data (CSV)", df.to_csv(index=False), file_name=f"{ticker}_raw.csv", mime="text/csv")

    st.subheader("FORECASTS")
    forecasts = forecast_all(df, periods=30)
    for model_name, fc in forecasts.items():
        st.markdown(f"### {model_name}")
        st.dataframe(fc)
        st.download_button(f"Download {model_name} forecast CSV", fc.to_csv(index=False), file_name=f"{ticker}_{model_name}.csv", mime="text/csv")
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=df['Date'], y=df['Close'], name='Historical'))
        fig.add_trace(go.Scatter(x=fc['Date'], y=fc['yhat'], name=f'{model_name} Forecast'))
        if model_name == "Prophet" and 'yhat_lower' in fc.columns and 'yhat_upper' in fc.columns:
            fig.add_trace(go.Scatter(x=fc['Date'], y=fc['yhat_lower'], name='Lower Bound', line=dict(dash='dot')))
            fig.add_trace(go.Scatter(x=fc['Date'], y=fc['yhat_upper'], name='Upper Bound', line=dict(dash='dot')))
        st.plotly_chart(fig, use_container_width=True, theme=None)

    st.markdown("---")
    st.subheader("Recent data (tail)")
    st.dataframe(df.tail(50), use_container_width=True)
else:
    st.info("Select ticker and press 'Run All' to fetch data and forecasts.")
